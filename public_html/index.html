
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Test</title>
    <style>
        body { margin: 0; }
        canvas { width: 600px; height: 600px }
    </style>
</head>
<body>
    <p>
        Connection test!
    </p>
    <script src="js/three.js"></script>
    <script src="js/Blocks.js"></script>
    <script src="js/controls/OrbitControls.js"></script>

        <script>
            var height = 600;
            var width = 600;

            var inPort = null;
            var outPort = null;

            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();

            var camera = new THREE.PerspectiveCamera( 75, width/height, 0.1, 1000 );
            camera.position.z = 5;

            var renderer = Blocks.makeRenderer();
            var canvas = renderer.domElement;
            document.body.appendChild( canvas );

            var scene = Blocks.makeScene();

            var controls = new THREE.OrbitControls( camera );
            controls.noRotate = true;

            var render = function () {
                // requestAnimationFrame( render );
                renderer.render(scene, camera);
            };
            controls.addEventListener( 'change', render );

            function onMouseDown( event ) {
                if (event.button !== 0) return;

                // calculate mouse position in normalized device coordinates // (-1 to +1) for both components
                mouse.x = ( event.layerX / width ) * 2 - 1;
                mouse.y = - ( event.layerY / height ) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObjects( scene.children, true );
                if (intersects.length >0) {
                    var obj = intersects[0].object;
                    handleSelect(obj);
                }
                else {
                    var wp = new THREE.Vector3(0, 0, 0);
                    wp.project(camera);
                    var pos = new THREE.Vector3(mouse.x, mouse.y, wp.z);
                    pos.unproject(camera);
                    var block = Blocks.makeBlock(pos.x, pos.y);
                    addObject(block);
                }
                render();
            }

            function handleSelect(obj) {
                Blocks.select(inPort, false);
                Blocks.select(outPort, false);

                if (obj.userData.type === "inPort") {
                    inPort = obj;
                }
                if (obj.userData.type === "outPort") {
                    outPort = obj;
                }
                if (obj.userData.type === "block") {
                    if (outPort === null) {
                        outPort = obj.children[1];
                    } else if (inPort === null) {
                        inPort = obj.children[0];
                    }
                }

                Blocks.select(inPort, true);
                Blocks.select(outPort, true);

                if (inPort && outPort) {
                    var block1 = outPort.parent;
                    var block2 = inPort.parent;
                    if (block1.uuid === block2.uuid) return;
                    var line = Blocks.connectBlocks(block1, block2);
                    Blocks.select(inPort, false);
                    Blocks.select(outPort, false);
                    inPort = null;
                    outPort = null;
                    addObject(line);
                }
            };

            function addObject(object) {
                scene.add(object);
            };

            canvas.addEventListener( 'mousedown', onMouseDown, false );
            // window.addEventListener( 'mousemove', onMouseMove, false ); TODO

            render();
        </script>
</body>
</html>











